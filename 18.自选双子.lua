--自选双子
--输入下面的代码后，重新开始一局新游戏
--除非重新加载了模组，否则不要重复输入代码！

---- 代码效果(不用管中文，全选复制即可) ----

--* 前置功能性代码（重复输入不额外生效）
l if not(REPENTOGON or _CBH)then local D,E,F,I,J,O,P,Y,W,A,B,C,G,H,K,L,Q,R=require'debug',{},'Function',Isaac,'Callback',{},pairs,true,{}_CBH,A,B,C,G,K,Q,R=Y,D.getlocal,D.setlocal,D.sethook,I.GetCallbacks,'Run'..J,function(i)for _,m in P(G(i))do local o=m[F]if not W[o]then m[F]=O[o]or R(o)end end end,function(f)local function r(...)local s={pcall(f,...)}if s[1]then return table.unpack(s,2)end end O[f],W[r]=r,f return r end L=function(i)_,i=A(3,i)if not E[i]then E[i]=Y Q(i)end end for _,i in P(ModCallbacks)do E[i]=Y end function Wrap()if not H then for i,_ in P(E)do Q(i)end C(function(e)local a=D.getinfo(2,'f').func if a==I['AddPriority'..J]then _,a=A(2,4)L(2)if not W[a]then B(2,4,O[a]or R(a))end elseif a==I['Remove'..J]then _,a=A(2,3)L(2)if not W[a]then B(2,3,O[a]or a)end elseif a==I[K]or a==I[K..'WithParam']or a==G then L(1)end end,'c')H=Y end end function Unwrap()if H then C()for i,_ in P(E)do for _,m in P(G(i))do m[F]=W[m[F]]or m[F]end end O,W,H={},{}end end end -- 安全包装,预防模组兼容问题
l local A,I,M=ModCallbacks,Isaac,'Mod'function CLM(t,m)for i,j in pairs(A)do t=I.GetCallbacks(j)for x=#t,1,-1 do m=t[x][M]if not(m and m.Name)then I.RemoveCallback(m,j,t[x].Function)end end end end -- 清理匿名模组回调,预防代码污染
--0. 避免代码污染和模组不兼容问题，游戏胜利后自动清除代码效果。
--依赖代码* | 提供接口: CLM()删除匿名回调; Wrap()包装模组回调; Unwrap()取消包装。
l Wrap,Unwrap=Wrap or CLM,Unwrap or CLM Wrap()CLM()Isaac.AddCallback({},ModCallbacks.MC_POST_GAME_END,function(_,f)if not f then Unwrap()CLM()end end)

--1. 每开始新游戏时，主角色P1为当前角色、副角色P2为上一轮游戏的P1，可通过连续开始两次新游戏实现自选双子进行游戏。
--仅支持单人角色的搭配，不支持雅各&以扫、(堕化)遗骸、(堕化、长子权)拉撒路。
--按住丢弃键切换两位玩家HUD显示，两位角色的复活道具分开计算，其余逻辑与雅各&以扫一致。
l local B,F,G,H,I,K,M,O,Q,T,U,W,X,Y,Z,Ad,Ca,In,Ma,Un,Et,Ev,Gp,A,C,D,E,J,L,N,P,R,S,V,Sp,Pr,Up,Tr,Gv,P1,P2,Bb=ButtonAction,'Parent',function()return Game():GetNumPlayers()end,GetPtrHash,InputHook,Isaac,ModCallbacks,'Position','PositionOffset',{},'Size','MoveSpeed','ControllerIndex','GetDamageCooldown','SetMinDamageCooldown','AddCacheFlags',CacheFlag,Input,math,table.unpack,EntityType,'EvaluateItems','GetPlayerType'Sp,R,Tr,Gv,V,A,P,D,L,N,S=Ca.CACHE_SPEED,In.IsActionPressed,In.IsActionTriggered,In.GetActionValue,M.MC_POST_PLAYER_UPDATE,K.AddCallback,K.GetPlayer,B.ACTION_DROP,{B.ACTION_LEFT,B.ACTION_RIGHT,B.ACTION_UP,B.ACTION_DOWN},{B.ACTION_ITEM,B.ACTION_PILLCARD},{B.ACTION_SHOOTLEFT,B.ACTION_SHOOTRIGHT,B.ACTION_SHOOTUP,B.ACTION_SHOOTDOWN}A(T,M.MC_EVALUATE_CACHE,function(_,e)if J and 1<G()then local a,b,h,v=P(),P(1),H(e)if h==H(a)then C=a[W]elseif h==H(b)then E=b[W]end if C and E then v=(C+E)/2 a[W],b[W]=v,v elseif C then b[Ad](b,Sp)b[Ev](b)elseif E then a[Ad](a,Sp)a[Ev](a)end end end,Sp)A(T,M.MC_POST_PEFFECT_UPDATE,function(_,p)p[W]=Ma.min(2,p[W])end)A(T,V,function(_,p)local e,f,h,r,x,y,z=P(),P(1),H(p)P1=P1 or e[Gp](e)if J then x=e[X]r=R(D,x)if P2 and 2>G()then K.ExecuteCommand('addplayer '..P2..' '..x)P(1)[F],Up=e,true return end y,z=H(e),H(f)if h==z then if Up or r and not Pr or not r and Pr then p[F],Up=not r and e or nil,false Game():GetHUD():AssignPlayerHUDs()end Pr,p[F]=r end if(p:IsDead()and not p:WillPlayerRevive()or p:IsCoopGhost())and(h==y or h==z)and y~=z then e:Kill()f:Kill()end end end)A(T,V,function(_,p)local a,b,h,e,v,s,t=P(),P(1),H(p)if 1<G()then s,t=a[Y](a),b[Y](b)if 1<Ma.abs(s-t)then a[Z](a,t)b[Z](b,s)end e=h==H(a)and b or h==H(b)and a if e then v=p[O]+p[Q]-e[O]-e[Q]if p[U]+e[U]>v:Length()then p:AddVelocity(.1*v:Normalized())end end end end)A(T,M.MC_POST_PLAYER_RENDER,function(_,p,o)local s,h,d,l=o+K.WorldToRenderPosition(p.Position+p.PositionOffset),H(p)d=h==H(P())and'P1'or h==H(P(1))and'P2'l=K.GetTextWidth(d)K.RenderText(d,s.X-l/2,s.Y,1,1,1,1)end)A(T,M.MC_INPUT_ACTION,function(_,e,h,a)e=e and e:ToPlayer()if e then local d,q,s,p,x,r,f,z,j,k,l=P(),H(P(1)),H(e)p,x=H(d),d[X]r,j,k,l=R(D,x),R(a,x),Tr(a,x),Gv(a,x)if h==I.IS_ACTION_PRESSED then f,z=false,j elseif h==I.IS_ACTION_TRIGGERED then f,z=false,k elseif h==I.GET_ACTION_VALUE then f,z=0,l end for _,v in pairs(N)do if a==v then if s==p and not r or s==q and r then return z else return f end end end if a==B.ACTION_BOMB then if s==p then Bb=0<e:GetNumBombs()elseif s==q and k and Bb and not e:HasGoldenBomb()then e:AddBombs(1)end end if s==q then for _,v in pairs(L)do if a==v then return not r and z or f end end end if a==D then for _,v in pairs({Un(L),Un(S)})do if R(v,x)or Tr(v,x)or 0<Gv(v,x)then return f end end end end end)A(T,M.MC_POST_GAME_STARTED,function(_,c)J=true if not c then P1,P2=P()[Gp](P()),P1 end if 1<G()then for i=0,1 do local p=P(i)p[Ad](p,Ca.CACHE_ALL)p[Ev](p)end end end)A(T,M.MC_PRE_GAME_EXIT,function()if 1<G()then P(1)[F],C,E=P()end J=false end)A(T,M.MC_PRE_ENTITY_SPAWN,function(_,t,v)if t==Et.ENTITY_SLOT and v==19 then return{Et.ENTITY_EFFECT,EffectVariant.EFFECT_NULL}end end)

--2. 从游戏中移除道具482(遥控器)
l local I,C,Y,T,A=Isaac,{482},true,{}A=I.AddCallback A(T,23,function(_,c)for _,v in pairs(C)do if c==v then return Y end end end)A(T,31,function(_,p)for _,i in pairs(C)do for _=1,p:GetCollectibleNum(i)do p:RemoveCollectible(i)end end end)A(T,37,function(p,f,v,s)if v==100 then repeat p,f=Game():GetItemPool()for _,i in pairs(C)do if i==s then f,s=1,p:GetCollectible(p:GetLastPool(),Y)break end end until not f return{v,s}end end)
--.